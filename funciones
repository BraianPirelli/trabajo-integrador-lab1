#include <iostream>
#include <stdlib.h>
#include <locale>
#include <time.h>
#include "funciones.h"

using namespace std;

const int TIPOS_CARTAS = 5, PALOS = 4, CARTAS_POR_MANO = 5;
void inicioPartida(int &maximaPuntuacion, string &maximoGanador, string &jugador_1, string &jugador_2, string corralJugador_1[], string corralJugador_2[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[], int CARTAS_POR_MANO);

void estadisticas(int maximaPuntuacion, string ganador);

void creditos();

int tirada_de_dados(string);

void preparacion_barajas(string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS]);

void repatir_cartas(string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], string []);

string quien_inicia(string jugador1, string jugador2, string corralJugador_1[], string corralJugador_2[]);

void iniciador_cartas_bloqueadas(bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[]);

void acciones_del_dado(int dado, string turno, string jugador1, string jugador2, string corralJugador1[], string corralJugador_2[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[], bool &jugador_1_paso_turno, bool &jugador_2_paso_turno, bool &le_robaron_al_1, bool &le_robaron_al_2);

void accion_1(string turno, string corral_propio[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas[]);

void accion_2(string turno, string corral_contrario[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas_jugador[]);

void accion_3(string turno, string corral_propio[], string corral_contrario[], bool cartas_bloqueadas_contrario[], bool cartas_bloqueadas_propias[], bool &le_robaron);

void accion_4(string turno, string corral_propio[]);

void accion_5(string turno, string corral_propio[], bool cartas_bloqueadas[]);

void accion_6(string turno, string jugador1, string jugador2, string corralJugador_1[], string corralJugador_2[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[], bool &jugador_1_paso_turno, bool &jugador_2_paso_turno, bool &le_robaron_al_1, bool &le_robaron_al_2);

int verificador_de_indices();

bool verificador_de_orden(string jugador_1, string jugador_2, string corraljugador_1[], string corraljugador_2[], int CARTAS_POR_MANO, string &ganador);

int verificador_de_desorden(string jugador_1, string jugador_2, string corraljugador_1[], string corraljugador_2[], int CARTAS_POR_MANO, string ganador);

int contador_de_puntos(string ganador, string jugador_1, string jugador_2, int dado_1, int dado_2, int cartas_desordenadas, bool jugador_1_paso_turno, bool jugador_2_paso_turno, bool le_robaron_al_1, bool le_robaron_al_2);

void asignacion_maxima_puntuacion(int puntuacionFinal, string ganador, int &maximaPuntuacion, string &maximoGanador);




/** pvp ----------------------------------------------------------------------------------------------------------------- **/
void inicioPartida(int &maximaPuntuacion, string &maximoGanador, string &jugador_1, string &jugador_2, string corralJugador_1[], string corralJugador_2[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[], int CARTAS_POR_MANO)
{

    int ronda = 0, dado, cartas_desordenadas, puntuacionFinal;
    bool finPartida = false;
    char confirmar;
    string turno, ganador;

    int dado_1, dado_2; // guarda el ultimo valor del dado de cada jugador

    bool jugador_1_paso_turno = false, jugador_2_paso_turno = false; // verifican si dicho jugador paso de turno

    bool le_robaron_al_1 = false, le_robaron_al_2 = false; // verifica si a dicho jugador le robaron una carta

    iniciador_cartas_bloqueadas(cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2);



    while(finPartida == false)
    {

        // la "ronda 0" es una forma subjetiva de usar el contador,
        // para que en primera instancia pida los nombres de los jugadores
        if (ronda == 0)
        {
            do
            {
                cout << "\tCLUTCH" << endl;
                cout << "---------------------------------------------------------------------------------------" << endl;

                cout << "Antes de comenzar debe registrar sus nombres: " << endl;

                // inicia el jugador 1 ingresando su nombre
                cout << endl;
                cout << "jugador 1, ingrese su nombre: ";
                cin >> jugador_1;
                cout << endl;

                // continua el jugador 2 ingresando su nombre
                cout << endl;
                cout << "jugador 2, ingrese su nombre: ";
                cin >> jugador_2;
                cout << endl;

                cout << "confirmar nombres" << endl;
                cout << "S - si\nN - no" << endl;
                cin >> confirmar;
                while(confirmar != 'N' && confirmar != 'n' && confirmar != 'S' && confirmar != 's')
                {
                    cout << "ERROR, INGRESE UNA CONFIRMACION VALIDA" << endl;
                    cin >> confirmar;
                }

            }
            while (confirmar == 'N' || confirmar == 'n');

            cout << "---------------------------------------------------------------------------------------" << endl;


            cout << system("cls");

            // cuando el contador esta en 1, primera ronda, se reparten las cartas, por unica vez, y luego
            // se desarrolla el juego en base a la logica de los dados
        }
        else if (ronda == 1)
        {
            cout << "\tCLUTCH" << endl;
            cout << "---------------------------------------------------------------------------------------" << endl;

            cout << "RONDA #" << ronda << endl;
            cout << jugador_1 << "  VS  " << jugador_2 << endl;
            cout << endl << "SE REPARTEN LAS CARTAS PARA CADA JUGADOR!!" << endl;


            // se asignan las cartas al primer jugador
            repatir_cartas(baraja_cartas_muestra, baraja_cartas_disponibles, corralJugador_1);

            cout << jugador_1 << ":" << endl;
            for (int x = 0; x < 5; x++)
            {
                cout << "\t" << corralJugador_1[x] << " " << endl;
            }


            cout << " " << endl;


            // se asignan las cartas al segundo jugador
            repatir_cartas(baraja_cartas_muestra, baraja_cartas_disponibles, corralJugador_2);

            cout << jugador_2 << ":" << endl;
            for (int x = 0; x < 5; x++)
            {
                cout << "\t" << corralJugador_2[x] << " " << endl;
            }

            cout << "---------------------------------------------------------------------------------------" << endl;

            finPartida = verificador_de_orden(jugador_1, jugador_2, corralJugador_1, corralJugador_2, CARTAS_POR_MANO, ganador);

            turno = quien_inicia(jugador_1, jugador_2, corralJugador_1, corralJugador_2);


            cout << system("pause");
            cout << system("cls");

        }
        else
        {
            cout << "\tCLUTCH" << endl;
            cout << "---------------------------------------------------------------------------------------" << endl;

            cout << "RONDA #" << (ronda) << endl;
            cout << endl;
            cout << jugador_1 << "  VS  " << jugador_2 << endl;
            cout << endl;

            if (turno == jugador_1)
            {


                cout << "TURNO DE " << jugador_1 << endl;
                cout << endl;

                cout << jugador_1 << ":" << endl;
                for (int x = 0; x < 5; x++)
                {
                    cout << "\t" << corralJugador_1[x] << " " << endl;
                }
                cout << endl;

                cout << jugador_2 << ":" << endl;
                for (int x = 0; x < 5; x++)
                {
                    cout << "\t" << corralJugador_2[x] << " " << endl;
                }
                cout << endl;

                // funcion de tirar dados

                dado = tirada_de_dados(turno);
                dado_1 = dado;


                // llamada a la funcion de los dados

                acciones_del_dado(dado, turno, jugador_1, jugador_2, corralJugador_1, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2, jugador_1_paso_turno, jugador_2_paso_turno, le_robaron_al_1, le_robaron_al_2);

                finPartida = verificador_de_orden(jugador_1, jugador_2, corralJugador_1, corralJugador_2, CARTAS_POR_MANO, ganador);


                // si el que inicio es el jugador 2, se define que el siguiente turno sera
                // del jugador 1
                turno = jugador_2;

            }
            else
            {

                cout << "TURNO DE " << jugador_2 << endl;
                cout << endl;

                cout << jugador_2 << ":" << endl;
                for (int x = 0; x < 5; x++)
                {
                    cout << "\t" << corralJugador_2[x] << " " << endl;
                }
                cout << endl;

                cout << jugador_1 << ":" << endl;
                for (int x = 0; x < 5; x++)
                {
                    cout << "\t" << corralJugador_1[x] << " " << endl;
                }
                cout << endl;

                // funcion de tirar dados

                dado = tirada_de_dados(turno);
                dado_2 = dado;

                // llamada a la funcion de los dados

                acciones_del_dado(dado, turno, jugador_1, jugador_2, corralJugador_1, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2, jugador_1_paso_turno, jugador_2_paso_turno, le_robaron_al_1, le_robaron_al_2);

                finPartida = verificador_de_orden(jugador_1, jugador_2, corralJugador_1, corralJugador_2, CARTAS_POR_MANO, ganador);


                // si el que inicio es el jugador 2, se define que el siguiente turno sera
                // del jugador 1
                turno = jugador_1;

            }

            cout << "---------------------------------------------------------------------------------------" << endl;


        }

        ronda++;

    }

    cartas_desordenadas = verificador_de_desorden(jugador_1, jugador_2, corralJugador_1, corralJugador_2, CARTAS_POR_MANO, ganador);

    puntuacionFinal = contador_de_puntos(ganador, jugador_1, jugador_2, dado_1, dado_2, cartas_desordenadas, jugador_1_paso_turno, jugador_2_paso_turno, le_robaron_al_1, le_robaron_al_2);

    if (puntuacionFinal > maximaPuntuacion)
    {

        asignacion_maxima_puntuacion(puntuacionFinal, ganador, maximaPuntuacion, maximoGanador);

    }



}


/** estadisticas -----------------------------------------------------------------------------------------------------------------**/
void estadisticas(int maxPuntuacion, string maxGanador)
{

    cout << "\tmejor puntuacion: " << maxPuntuacion << " " << maxGanador << endl;

    cout << "---------------------------------------------------------------------------------------" << endl;
}


/** creditos ----------------------------------------------------------------------------------------------------------------- **/

void creditos()
{
    cout << "CREDITOS" << endl;
    cout << "---------------------------------------------------------------------------------------" << endl;
    cout << endl;
    cout << "\t-BARRIENTOS ABRIL" << endl;
    cout << "\t-DIAZ MARCELO" << endl;
    cout << "\t-PIRELLI BRAIAN" << endl;
    cout << "\t-SEQUEA ASDRUBAL" << endl;
    cout << endl;
    cout << "---------------------------------------------------------------------------------------" << endl;
}


/** tirada de dados ----------------------------------------------------------------------------------------------------------------- **/
int tirada_de_dados(string turno)
{

    int dado = 1 + rand()%(6);

    cout << "EL JUGADOR " << turno << " AGARRO Y TIRO EL DADO" << endl;
    cout << system("pause");
    cout << system("cls");
    cout << "SACO EL DADO: " << endl;
    cout << endl;

    switch (dado)
    {
    case 1:
        cout << "\t\t+-----------+" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|     x     |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t+-----------+" << endl;


        cout << system("pause");
        cout << system("cls");
        break;

    case 2:
        cout << "\t\t+-----------+" << endl;
        cout << "\t\t|  x        |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|        x  |" << endl;
        cout << "\t\t+-----------+" << endl;


        cout << system("pause");
        cout << system("cls");
        break;

    case 3:
        cout << "\t\t+-----------+" << endl;
        cout << "\t\t| x         |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|     x     |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|          x|" << endl;
        cout << "\t\t+-----------+" << endl;


        cout << system("pause");
        cout << system("cls");
        break;

    case 4:
        cout << "\t\t+-----------+" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t+-----------+" << endl;


        cout << system("pause");
        cout << system("cls");
        break;

    case 5:
        cout << "\t\t+-----------+" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|     x     |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t+-----------+" << endl;


        cout << system("pause");
        cout << system("cls");
        break;

    case 6:
        cout << "\t\t+-----------+" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t|           |" << endl;
        cout << "\t\t|  x     x  |" << endl;
        cout << "\t\t+-----------+" << endl;


        cout << system("pause");
        cout << system("cls");
        break;

    }

    cout << system("pause");
    cout << system("cls");

    return dado;
}


/** carga de matrices -----------------------------------------------------------------------------------------------------------**/

void preparacion_barajas(string baraja_cartas_muestra[][4], bool baraja_cartas_disponibles[][4])
{

    const int TIPOS = 5;
    const int PALOS = 4;

    const string nombresCartas[] = {"10", "J", "Q", "K", "A"};
    const string nombresPalos[] = {"corazones", "picas", "diamantes", "trebol"};

    for (int x = 0; x < TIPOS; x++)
    {
        for (int y = 0; y < PALOS; y++)
        {
            baraja_cartas_muestra[x][y] = nombresCartas[x] + " " + nombresPalos[y];

            baraja_cartas_disponibles[x][y] = true;
        }
    }
}


/** reparticion de cartas ---------------------------------------------------------------------------------------------------------**/

void repatir_cartas(string baraja_cartas_muestra[][4], bool baraja_cartas_disponibles[][4], string corral[])
{

    srand(time(NULL));

    int manoDeCartas = 5;
    int indiceCarta;
    int indicePalo;

    for (int x = 0; x < manoDeCartas; x++)
    {
        indiceCarta = rand()%(5); // CAMBIE LOS INDICES YA QUE DE LA FORMA QUE ESTABAN ESCRITOS
        indicePalo = rand()%(4);  // ANTES, NO SE ANALIZABA EL "AS"

        // pregunto si en la posicion del indice random "carta" y random "palo", esta disponible
        if (baraja_cartas_disponibles[indiceCarta][indicePalo] == true)
        {

            // si esta, se asigna al "corral" el valor que tiene almacenado la matriz "muestra",
            // y la matriz "disponible" se pone en false
            corral[x] = baraja_cartas_muestra[indiceCarta][indicePalo];
            baraja_cartas_disponibles[indiceCarta][indicePalo] = false;

        }
        else
        {
            // en caso de no estar disponible esa carta se generan dos indices nuevos hasta que si este disponible
            while (baraja_cartas_disponibles[indiceCarta][indicePalo] == false)
            {

                indiceCarta = rand()%(5); // CAMBIE LOS INDICES PARA QUE SE PUEDA RECORRER DE FORMA MAS EFICAS
                indicePalo = rand()%(4);  // LA MATRIZ

            }
            // una vez este disponible se asignan al "corral" y se asigna false a la matriz "disponible"
            corral[x] = baraja_cartas_muestra[indiceCarta][indicePalo];
            baraja_cartas_disponibles[indiceCarta][indicePalo] = false;
        }

        // el proceso debe repetirse 5 veces ya que el "corral" o mano de jugador se compone de 5 cartas :)
    }
}


/** quien comienza la partida ---------------------------------------------------------------------------------------------------------**/

string quien_inicia(string jugador1, string jugador2, string corralJugador_1[], string corralJugador_2[])
{
    int cantidad_j1 = 0, cantidad_j2 = 0;
    for (int x = 0; x < CARTAS_POR_MANO; x++)
    {
        if (corralJugador_1[x] == "A corazones" || corralJugador_1[x] == "A picas" || corralJugador_1[x] == "A diamantes" || corralJugador_1[x] == "A trebol")
        {
            cantidad_j1++;
        }
    }

    for (int x = 0; x < CARTAS_POR_MANO; x++)
    {
        if (corralJugador_2[x] == "A corazones" || corralJugador_2[x] == "A picas" || corralJugador_2[x] == "A diamantes" || corralJugador_2[x] == "A trebol")
        {
            cantidad_j2++;
        }
    }

    if (cantidad_j1 == cantidad_j2)
    {
        cantidad_j1 = 0, cantidad_j2 = 0;
        for (int x = 0; x < CARTAS_POR_MANO; x++)
        {
            if (corralJugador_1[x] == "K corazones" || corralJugador_1[x] == "K picas" || corralJugador_1[x] == "K diamantes" || corralJugador_1[x] == "K trebol")
            {
                cantidad_j1++;
            }
        }

        for (int x = 0; x < CARTAS_POR_MANO; x++)
        {
            if (corralJugador_2[x] == "K corazones" || corralJugador_2[x] == "K picas" || corralJugador_2[x] == "K diamantes" || corralJugador_2[x] == "K trebol")
            {
                cantidad_j2++;
            }
        }


        if (cantidad_j1 == cantidad_j2)
        {
            cantidad_j1 = 0, cantidad_j2 = 0;
            for (int x = 0; x < CARTAS_POR_MANO; x++)
            {
                if (corralJugador_1[x] == "Q corazones" || corralJugador_1[x] == "Q picas" || corralJugador_1[x] == "Q diamantes" || corralJugador_1[x] == "Q trebol")
                {
                    cantidad_j1++;
                }
            }

            for (int x = 0; x < CARTAS_POR_MANO; x++)
            {
                if (corralJugador_2[x] == "Q corazones" || corralJugador_2[x] == "Q picas" || corralJugador_2[x] == "Q diamantes" || corralJugador_2[x] == "Q trebol")
                {
                    cantidad_j2++;
                }
            }

            if (cantidad_j1 == cantidad_j2)
            {
                cantidad_j1 = 0, cantidad_j2 = 0;
                for (int x = 0; x < CARTAS_POR_MANO; x++)
                {
                    if (corralJugador_1[x] == "J corazones" || corralJugador_1[x] == "J picas" || corralJugador_1[x] == "J diamantes" || corralJugador_1[x] == "J trebol")
                    {
                        cantidad_j1++;
                    }
                }

                for (int x = 0; x < CARTAS_POR_MANO; x++)
                {
                    if (corralJugador_2[x] == "J corazones" || corralJugador_2[x] == "J picas" || corralJugador_2[x] == "J diamantes" || corralJugador_2[x] == "J trebol")
                    {
                        cantidad_j2++;
                    }
                }

                if (cantidad_j1 == cantidad_j2)
                {
                    cantidad_j1 = 0, cantidad_j2 = 0;
                    for (int x = 0; x < CARTAS_POR_MANO; x++)
                    {
                        if (corralJugador_1[x] == "10 corazones" || corralJugador_1[x] == "10 picas" || corralJugador_1[x] == "10 diamantes" || corralJugador_1[x] == "10 trebol")
                        {
                            cantidad_j1++;
                        }
                    }

                    for (int x = 0; x < CARTAS_POR_MANO; x++)
                    {
                        if (corralJugador_2[x] == "10 corazones" || corralJugador_2[x] == "10 picas" || corralJugador_2[x] == "10 diamantes" || corralJugador_2[x] == "10 trebol")
                        {
                            cantidad_j2++;
                        }
                    }

                    if (cantidad_j1 > cantidad_j2)
                    {
                        return jugador1;
                    }
                    else
                    {
                        return jugador2;
                    }
                }
                else if (cantidad_j1 > cantidad_j2)
                {
                    return jugador1;
                }
                else
                {
                    return jugador2;
                }

            }
            else if (cantidad_j1 > cantidad_j2)
            {
                return jugador1;
            }
            else
            {
                return jugador2;
            }

        }
        else if (cantidad_j1 > cantidad_j2)
        {
            return jugador1;
        }
        else
        {
            return jugador2;
        }

    }
    else if (cantidad_j1 > cantidad_j2)
    {
        return jugador1;
    }
    else
    {
        return jugador2;
    }
}


/** iniciador de cartas bloqueadas ---------------------------------------------------------------------------------------------------------**/

void iniciador_cartas_bloqueadas(bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[])
{

    for (int x = 0; x < CARTAS_POR_MANO; x++)
    {
        cartas_bloqueadas_jugador1[x] = false;
        cartas_bloqueadas_jugador2[x] = false;
    }

}


/** acciones del dado -----------------------------------------------------------------------------------------------------------------------*/

void acciones_del_dado(int dado, string turno, string jugador1, string jugador2, string corralJugador_1[], string corralJugador_2[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[], bool &jugador_1_paso_turno, bool &jugador_2_paso_turno, bool &le_robaron_al_1, bool &le_robaron_al_2)
{


    switch(dado)
    {
    case 1:
        if (turno == jugador1)
        {
            accion_1(turno, corralJugador_1, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1);
        }
        else
        {
            accion_1(turno, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador2);
        }
        cout << system("pause");
        cout << system("cls");
        break;
    case 2:
        if (turno == jugador1)
        {
            accion_2(turno, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador2);
        }
        else
        {
            accion_2(turno, corralJugador_1, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1);
        }
        cout << system("pause");
        cout << system("cls");
        break;
    case 3:
        if (turno == jugador1)
        {
            accion_3(turno, corralJugador_1, corralJugador_2, cartas_bloqueadas_jugador2, cartas_bloqueadas_jugador1, le_robaron_al_1);
        }
        else
        {
            accion_3(turno, corralJugador_2, corralJugador_1, cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2, le_robaron_al_2);
        }
        cout << system("pause");
        cout << system("cls");
        break;
    case 4:
        if (turno == jugador1)
        {
            accion_4(turno, corralJugador_1);
        }
        else
        {
            accion_4(turno, corralJugador_2);
        }
        cout << system("pause");
        cout << system("cls");
        break;
    case 5:
        if (turno == jugador1)
        {
            accion_5(turno, corralJugador_1, cartas_bloqueadas_jugador1);
        }
        else
        {
            accion_5(turno, corralJugador_2, cartas_bloqueadas_jugador2);
        }
        cout << system("pause");
        cout << system("cls");
        break;
    case 6:
        if (turno == jugador1)
        {

            accion_6(turno, jugador1, jugador2, corralJugador_1, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2, jugador_1_paso_turno, jugador_2_paso_turno, le_robaron_al_1, le_robaron_al_2);
        }
        else
        {
            accion_6(turno, jugador1, jugador2, corralJugador_1, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2, jugador_1_paso_turno, jugador_2_paso_turno, le_robaron_al_1, le_robaron_al_2);
        }
        cout << system("pause");
        cout << system("cls");
        break;
    }
}


/** accion del dado 1 (dejar una propia y levantar una nueva)------------------------------------------------------------------------------------------------------------------------*/

void accion_1(string turno, string corral_propio[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas[])
{



    int seleccion_propio, seleccion_tipo, seleccion_palo;
    string temp; // variable temporal auxiliar

    cout << "turno del jugador " << turno << endl << endl;

    for (int x = 0; x < 5; x++)
    {
        cout << "\t" << corral_propio[x] << " " << endl;
    }
    cout << endl;
    cout << "ingrese una carta propia, para enviar al mazo y levantar una nueva" << endl;
    // se llama a la funcion para verificar
    // que no se ingrese una letra en el indice
    seleccion_propio = verificador_de_indices();


    /*
    codigo anterior
    // Obtener la selección del usuario para la carta del propio corral (1-5)
    cout << "Elija una carta de su propio corral (1-5) \npara mandarla al mazo y levantar una nueva: ";
    cin >> seleccion_propio;

    // VERIFICA QUE LOS INDICES SEAN CORRECTOS
    while (seleccion_propio < 1 || seleccion_propio > 5){
        cout << "ERROR, SELECCION INVALIDA, INGRESE OTRAS CARTAS" << endl;
        cin >> seleccion_propio;
    }

    seleccion_propio--; // Convertir a índice de arreglo (0-4)

    */



    // Obtener una carta del mazo (simulado aquí como una carta aleatoria)
    seleccion_tipo = rand() % TIPOS_CARTAS; // como usamos una matriz, deben ser dos indices decidi probar modificando la accion
    seleccion_palo = rand() % PALOS;        // del dado usando el mismo metodo que usamos para repartir las cartas aleatoriamente


    // pregunta si la carta que el jugador eligio de su mano esta bloqueada,
    // si es verdad la desbloquea
    if (cartas_bloqueadas[seleccion_propio] == true)
    {
        cartas_bloqueadas[seleccion_propio] = false;
    }


    temp = corral_propio[seleccion_propio];

    if (baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] == true)  // primeramente verifica que la carta este disponible
    {

        // Realiza el intercambio de cartas si la carta esta disponible

        for (int x = 0; x < TIPOS_CARTAS; x++)
        {
            for (int y = 0; y < PALOS; y++)
            {

                // aca lo que hace es buscar la carta que selecciono el jugador
                // en la baraja de muestra, una vez que la encuentra
                // usa los indices de esa carta (alojados en la "baraja muestra",
                // usa ese indice en la "baraja disponibles", y convierte la carta a disponible
                if (temp == baraja_cartas_muestra[x][y])
                {
                    baraja_cartas_disponibles[x][y] = true;
                }
            }
        }
        // aca, en base a la carta disponible, reemplaza la carta de "corral propio"
        // con una aleatoria obtenida de la "baraja muestra".
        corral_propio[seleccion_propio] = baraja_cartas_muestra[seleccion_tipo][seleccion_palo];

        // y aca, lo que hace es poner, en false la carta asi ya no esta disponible para su eleccion.
        baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] = false;

    }
    else
    {
        // en caso de no estar disponible genera indices
        // hasta toparse con una posicion de carta disponible
        while (baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] == false)
        {
            seleccion_tipo = rand() % TIPOS_CARTAS;
            seleccion_palo = rand() % PALOS;
        }

        // Realizar el intercambio de cartas

        for (int x = 0; x < TIPOS_CARTAS; x++)
        {
            for (int y = 0; y < PALOS; y++)
            {
                if (temp == baraja_cartas_muestra[x][y])
                {
                    baraja_cartas_disponibles[x][y] = true;
                }
            }
        }
        corral_propio[seleccion_propio] = baraja_cartas_muestra[seleccion_tipo][seleccion_palo];

        baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] = false;
    }
}


/** accion del dado 2 (dejar una del rival y levantar una nueva)------------------------------------------------------------------------------------------------------------------------*/

void accion_2(string turno, string corral_contrario[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas[])
{
    int seleccion_contrario, seleccion_tipo, seleccion_palo;
    string temp; // variables temporal / auxiliar
    cout << "turno del jugador " << turno << endl << endl;


    for (int x = 0; x < 5; x++)
    {
        cout << "\t" << corral_contrario[x] << " " << endl;
    }
    cout << endl;


    // Obtener la selección del usuario para la carta del corral del contrario (1-5)
    cout << "Elija una carta del corral del contrario (1-5) \npara mandarla al mazo y levantar una nueva: ";

    seleccion_contrario = verificador_de_indices();

    // verifica que la carta en esa seleccion no este bloqueada por su dueño
    while (cartas_bloqueadas[seleccion_contrario] == true)
    {

        cout << "no se puede seleccionar esta carta, el dueño la bloqueo" << endl;
        seleccion_contrario = verificador_de_indices();
    }

    // Obtener una carta del mazo (simulado aquí como una carta aleatoria)
    seleccion_tipo = rand() % TIPOS_CARTAS;
    seleccion_palo = rand() % PALOS;




    if (baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] == true)  // primeramente verifica que la carta este disponible
    {

        // Realiza el intercambio de cartas si la carta esta disponible

        for (int x = 0; x < TIPOS_CARTAS; x++)
        {
            for (int y = 0; y < PALOS; y++)
            {

                // aca lo que hace es buscar la carta que selecciono el jugador
                // en la baraja de muestra, una vez que la encuentra
                // usa los indices de esa carta (alojados en la "baraja muestra",
                // usa ese indice en la "baraja disponibles", y convierte la carta a disponible
                if (temp == baraja_cartas_muestra[x][y])
                {
                    baraja_cartas_disponibles[x][y] = true;
                }
            }
        }
        // aca, en base a la carta disponible, reemplaza la carta de "corral propio"
        // con una aleatoria obtenida de la "baraja muestra".
        corral_contrario[seleccion_contrario] = baraja_cartas_muestra[seleccion_tipo][seleccion_palo];

        // y aca, lo que hace es poner, en false la carta asi ya no esta disponible para su eleccion.
        baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] = false;

    }
    else
    {
        // en caso de no estar disponible genera indices
        // hasta toparse con una posicion de carta disponible
        while (baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] == false)
        {
            seleccion_tipo = rand() % TIPOS_CARTAS;
            seleccion_palo = rand() % PALOS;
        }

        // Realizar el intercambio de cartas

        for (int x = 0; x < TIPOS_CARTAS; x++)
        {
            for (int y = 0; y < PALOS; y++)
            {
                if (temp == baraja_cartas_muestra[x][y])
                {
                    baraja_cartas_disponibles[x][y] = true;
                }
            }
        }
        corral_contrario[seleccion_contrario] = baraja_cartas_muestra[seleccion_tipo][seleccion_palo];

        baraja_cartas_disponibles[seleccion_tipo][seleccion_palo] = false;
    }
}


/** accion del dado 3 (intercambiar una carta propia con una del rival)------------------------------------------------------------------------------------------------------------------------*/

void accion_3(string turno, string corral_propio[], string corral_contrario[], bool cartas_bloqueadas_contrario[], bool cartas_bloqueadas_propias[], bool &le_robaron)
{
    int seleccion_contrario, seleccion_propio;
    string temp; // variables temporal / auxiliar

    le_robaron = true;

    cout << "turno del jugador " << turno << endl << endl;


    cout << "INTERCAMBIE CARTA PROPIA POR UNA DEL CONTRARIO" << endl << endl;

    cout << "(SI SU CARTA PROPIA ELEGIDA, ESTA BLOQUEADA)" << endl;
    cout << "(SE DESBLOQUEARA E INTERCAMBIARA)" << endl << endl;


    // muestra los mazos para hacer mas interactivo
    cout << "corral contrario:" << endl;
    for (int x = 0; x < 5; x++)
    {
        cout << "\t" << corral_contrario[x] << " " << endl;
    }
    cout << endl;


    cout << "corral propio:" << endl;
    for (int x = 0; x < 5; x++)
    {
        cout << "\t" << corral_propio[x] << " " << endl;
    }
    cout << endl;

    ///////////////////////////////////////////////////////////////////


    // Obtener la selección del usuario para la carta del corral del contrario (1-5)
    cout << "Elija una carta del corral del contrario (1-5): ";

    seleccion_contrario = verificador_de_indices();


    // verifica que la carta en esa seleccion no este bloqueada por su dueño
    while (cartas_bloqueadas_contrario[seleccion_contrario] == true)
    {

        cout << "no se puede seleccionar esta carta, el duenio la bloqueo" << endl;

        seleccion_contrario = verificador_de_indices();

    }


    // Obtener la selección del usuario para la carta del corral del contrario (1-5)
    cout << "Elija una carta del corral propio (1-5): ";
    seleccion_propio = verificador_de_indices();



    // verifica que la carta en esa seleccion bloqueada por si mismo
    // si lo esta, la desbloquea e intercambia
    if (cartas_bloqueadas_propias[seleccion_propio] == true)
    {

        cartas_bloqueadas_propias[seleccion_propio] = false;

    }



    // Realizar el intercambio de cartas
    temp = corral_propio[seleccion_propio];
    corral_propio[seleccion_propio] = corral_contrario[seleccion_contrario];
    corral_contrario[seleccion_contrario] = temp;
}


/** accion del dado 4 (intercambiar las posiciones de cartas propias)------------------------------------------------------------------------------------------------------------------------*/

void accion_4(string turno, string corral_propio[])
{
    int primera_seleccion, segunda_seleccion;
    string temp; // VARIABLE TEMPORAL / AUXILIAR
    cout << "turno del jugador " << turno << endl << endl;


    for (int x = 0; x < 5; x++)
    {
        cout << "\t" << corral_propio[x] << " " << endl;
    }
    cout << endl;



    // Obtener las selecciones del usuario para las cartas del propio corral (1-5)
    cout << "Elija dos cartas de su propio corral (1-5), separadas por un espacio: " << endl;

    cout << "primera carta: ";
    primera_seleccion = verificador_de_indices();
    cout << "segunda carta: ";
    segunda_seleccion = verificador_de_indices();



    // Realizar el intercambio de cartas
    // Realizar el intercambio de cartas
    temp = corral_propio[primera_seleccion];
    corral_propio[primera_seleccion] = corral_propio[segunda_seleccion];
    corral_propio[segunda_seleccion] = temp;
}


/** accion del dado 5 (elegir una carta propia para bloquear)------------------------------------------------------------------------------------------------------------------------*/

void accion_5(string turno, string corral_propio[], bool cartas_bloqueadas[])
{
    int seleccion;
    cout << "turno del jugador " << turno << endl << endl;


    for (int x = 0; x < 5; x++)
    {
        cout << "\t" << corral_propio[x] << " " << endl;
    }
    cout << endl;


    // Obtener la selección del usuario para la carta del propio corral (1-5)
    cout << "Elija una carta de su propio corral (1-5) para bloquear: " << endl;
    cout << "(considere que si la carta ya se encuentra bloqueada, se desbloqueara)" << endl;

    seleccion = verificador_de_indices();
    if (cartas_bloqueadas[seleccion] == true)
    {
        cartas_bloqueadas[seleccion] = false;
    }

    // Marcar la carta como bloqueada
    cartas_bloqueadas[seleccion] = true;
}


/** accion del dado 6 ------------------------------------------------------------------------------------------------------------------------*/

void accion_6(string turno, string jugador1, string jugador2, string corralJugador_1[], string corralJugador_2[], string baraja_cartas_muestra[TIPOS_CARTAS][PALOS], bool baraja_cartas_disponibles[TIPOS_CARTAS][PALOS], int TIPOS_CARTAS, int PALOS, bool cartas_bloqueadas_jugador1[], bool cartas_bloqueadas_jugador2[], bool &jugador_1_paso_turno, bool &jugador_2_paso_turno, bool &le_robaron_al_1, bool &le_robaron_al_2)
{
    char eleccion;

    cout << "JUGADOR " << turno << " ELIJA UNA OPCION DE LAS DISPONIBLES" << endl << endl;

    cout << "\t+-----------------------------------------------------------------------------------+" << endl;
    cout << "\t|      1    |                 DEJAR UNA CARTA PROPIA Y LEVANTAR UNA NUEVA           |" << endl;
    cout << "\t+-----------------------------------------------------------------------------------+" << endl;
    cout << "\t|      2    |               DEJAR UNA CARTA DEL RIVAL Y LEVANTAR UNA NUEVA          |" << endl;
    cout << "\t+-----------------------------------------------------------------------------------+" << endl;
    cout << "\t|      3    |               INTERCAMBIE UNA CARTA DEL RIVAL CON UNA PROPIA          |" << endl;
    cout << "\t+-----------------------------------------------------------------------------------+" << endl;
    cout << "\t|      4    |         ELIJA 2 CARTAS DEL CORRAL PROPIO E INTERCAMBIAR SUS LUGARES   |" << endl;
    cout << "\t+-----------------------------------------------------------------------------------+" << endl;
    cout << "\t|      5    |              SELECCIONAR UNA CARTA DEL CORRAL PROPIO PARA BLOQUEAR    |" << endl;
    cout << "\t+-----------------------------------------------------------------------------------+" << endl;
    cout << "\t|      6    |                                 PASAR EL TURNO                        |" << endl;
    cout << "\t+-----------------------------------------------------------------------------------+" << endl;

    cin >> eleccion;

    while(eleccion != '1' && eleccion != '2' && eleccion != '3'&& eleccion != '4'&& eleccion != '5'&& eleccion != '6')
    {

        cout << "ERROR, LA ELECCION ES INVALIDA >:C" << endl;
        cout << "VUELVA A INGRESAR SU ELECCION" << endl;

        cin >> eleccion;
        cout << system("pause");
        cout << system("cls");
    }


    switch (eleccion)
    {

    case '1':
        if (turno == jugador1)
        {
            accion_1(turno, corralJugador_1, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1);
        }
        else
        {
            accion_1(turno, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador2);
        }
        cout << system("pause");
        cout << system("cls");
        break;

    case '2':
        if (turno == jugador1)
        {
            accion_2(turno, corralJugador_2, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador2);
        }
        else
        {
            accion_2(turno, corralJugador_1, baraja_cartas_muestra, baraja_cartas_disponibles, TIPOS_CARTAS, PALOS, cartas_bloqueadas_jugador1);
        }
        cout << system("pause");
        cout << system("cls");
        break;

    case '3':
        if (turno == jugador1)
        {
            accion_3(turno, corralJugador_1, corralJugador_2, cartas_bloqueadas_jugador2, cartas_bloqueadas_jugador1, le_robaron_al_1);
        }
        else
        {
            accion_3(turno, corralJugador_2, corralJugador_1, cartas_bloqueadas_jugador1, cartas_bloqueadas_jugador2, le_robaron_al_2);
        }
        cout << system("pause");
        cout << system("cls");
        break;

    case '4':
        if (turno == jugador1)
        {
            accion_4(turno, corralJugador_1);
        }
        else
        {
            accion_4(turno, corralJugador_2);
        }
        cout << system("pause");
        cout << system("cls");
        break;

    case '5':
        if (turno == jugador1)
        {
            accion_5(turno, corralJugador_1, cartas_bloqueadas_jugador1);
        }
        else
        {
            accion_5(turno, corralJugador_2, cartas_bloqueadas_jugador2);
        }
        cout << system("pause");
        cout << system("cls");
        break;

    case '6':
        if (turno == jugador1)
        {
            cout << "EL JUGADOR " << turno << " HA ELEGIDO LA OPCION DE PASAR EL TURNO" << endl;
            jugador_1_paso_turno = true;
        }
        else
        {
            cout << "EL JUGADOR " << turno << " HA ELEGIDO LA OPCION DE PASAR EL TURNO" << endl;
            jugador_2_paso_turno = true;
        }
        cout << system("pause");
        cout << system("cls");
        break;
    }
}


/** verificador de indices ------------------------------------------------------------------------------------------------------------------------*/


int verificador_de_indices()
{
    int indice;
    char caracter;

    // primeramenete, se ingresa un numero
    // se hace en tipo CHAR, ya que la verificacion
    // se realiza en ASCII
    cin >> caracter;


    // en este punto realiza una comparacion entre el valor del caracter(char)
    // convertido a entero(int), y pregunta si estan dentro del rango valido
    //     49 - 1
    //     50 - 2
    //     51 - 3
    //     52 - 4
    //     53 - 5
    // si el numero / caracter es valido, le resta su respectivo numero en ASCII
    // para convertirlo en indice, y lo retorna al flujo original

    if ((int)caracter > 48 && (int)caracter <54)
    {

        indice = (int)caracter - 49;
        return indice;

    }
    else
    {

        // en caso de no estar en el rango valido
        // vuelve a pedir el ingreso del numero
        // hasta que este sea valido
        while ((int)caracter < 49 || (int)caracter >53)
        {

            cout << "ingrese un numero correcto" << endl;
            cin >> caracter;

        }
        indice = (int)caracter - 49;
        return indice;

    }


}


/** verificador de orden de cada corral ------------------------------------------------------------------------------------------------------------------------*/


bool verificador_de_orden(string jugador_1, string jugador_2, string corraljugador_1[], string corraljugador_2[], int CARTAS_POR_MANO, string &ganador)
{

    const string barajaDiamante[] = {"10 diamante", "j diamante", "Q diamante", "K diamante", "A diamante"};
    const string barajaCorazon[] = {"10 corazon", "j corazon", "Q corazon", "K corazon", "A corazon"};
    const string barajaPicas[] = {"10 picas", "j picas", "Q picas", "K picas", "A picas"};
    const string barajaTrebol[] = {"10 trebol", "j trebol", "Q trebol", "K trebol", "A trebol"};

    int ordenJugador_1 = 0;
    int ordenJugador_2 = 0;

    for (int x = 0; x < CARTAS_POR_MANO; x++)
    {
        if (corraljugador_1[x] == barajaDiamante[x] || corraljugador_1[x] == barajaCorazon[x]|| corraljugador_1[x] == barajaPicas[x] || corraljugador_1[x] == barajaTrebol[x])
        {
            ordenJugador_1++;
        }

        if (corraljugador_2[x] == barajaDiamante[x] || corraljugador_2[x] == barajaCorazon[x]|| corraljugador_2[x] == barajaPicas[x] || corraljugador_2[x] == barajaTrebol[x])
        {
            ordenJugador_2++;
        }
    }


    if (ordenJugador_1 == 5)
    {

        cout << "FELICIDADES JUGADOR " << jugador_1 << " SU CORRAL ESTA ORDENADO" << endl;
        ganador = jugador_1;
        return true;

    }
    else if (ordenJugador_2 == 5)
    {

        cout << "FELICIDADES JUGADOR " << jugador_2 << " SU CORRAL ESTA ORDENADO" << endl;
        ganador = jugador_2;
        return true;

    }
    else
    {
        return false;
    }

}


/** verificador de desorden del corral perdedor ------------------------------------------------------------------------------------------------------------------------*/


int verificador_de_desorden(string jugador_1, string jugador_2, string corraljugador_1[], string corraljugador_2[], int CARTAS_POR_MANO, string ganador)
{

    const string barajaDiamante[5] = {"10 diamante", "j diamante", "Q diamante", "K diamante", "A diamante"};
    const string barajaCorazon[5] = {"10 corazon", "j corazon", "Q corazon", "K corazon", "A corazon"};
    const string barajaPicas[5] = {"10 picas", "j picas", "Q picas", "K picas", "A picas"};
    const string barajaTrebol[5] = {"10 trebol", "j trebol", "Q trebol", "K trebol", "A trebol"};

    int desordenJugador = 0;


    if (ganador == jugador_1)
    {

        for (int x = 0; x < CARTAS_POR_MANO; x++)
        {
            if (corraljugador_2[x] != barajaDiamante[x] || corraljugador_2[x] != barajaCorazon[x]|| corraljugador_2[x] != barajaPicas[x] || corraljugador_2[x] != barajaTrebol[x])
            {
                desordenJugador += 5;
            }
        }

    }
    else
    {

        for (int x = 0; x < CARTAS_POR_MANO; x++)
        {
            if (corraljugador_1[x] != barajaDiamante[x] || corraljugador_1[x] != barajaCorazon[x]|| corraljugador_1[x] != barajaPicas[x] || corraljugador_1[x] != barajaTrebol[x])
            {
                desordenJugador += 5;
            }
        }

    }

    return desordenJugador;
}


/** contador de puntos ------------------------------------------------------------------------------------------------------------------------*/


int contador_de_puntos(string ganador, string jugador_1, string jugador_2, int dado_1, int dado_2, int cartas_desordenadas, bool jugador_1_paso_turno, bool jugador_2_paso_turno, bool le_robaron_al_1, bool le_robaron_al_2)
{

    int puntuacionFinal = 15;

    if (ganador == jugador_1)
    {

        if (dado_1 == 3)
        {
            puntuacionFinal += 10;
        }

        puntuacionFinal += cartas_desordenadas;


        // en estos casos las declaraciones se encuentran negadas ya que, las variables se declaran en false
        // por logica (si no te robaron una carta/no pasaste de turno) estan en false
        // si si te robaron / pasaste de turno, se pone en true
        // la pregunta es si no te robaron / pasaste de turno, debe sumar, pero si es asi la variable esta en false
        // entonces, para que de verdadero debe ser negada
        if (!jugador_1_paso_turno)
        {
            puntuacionFinal += 10;
        }

        if (!le_robaron_al_1)
        {
            puntuacionFinal += 5;
        }

    }
    else
    {

        if (dado_2 == 3)
        {
            puntuacionFinal += 10;
        }

        puntuacionFinal += cartas_desordenadas;

        if (!jugador_2_paso_turno)
        {
            puntuacionFinal += 10;
        }


        if (!le_robaron_al_2)
        {
            puntuacionFinal += 5;
        }


    }

    return puntuacionFinal;
}


/** asignacion de maxima puntuacion ------------------------------------------------------------------------------------------------------------------------*/


void asignacion_maxima_puntuacion(int puntuacionFinal, string ganador, int &maximaPuntuacion, string &maximoGanador)
{

    maximoGanador = ganador;
    maximaPuntuacion = puntuacionFinal;

}


